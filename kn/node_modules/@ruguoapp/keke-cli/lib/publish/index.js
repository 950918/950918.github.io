#!/usr/bin/env node
const path = require('path')
const fs = require('fs')
const md5 = require('md5')
const program = require('commander')
const { upload, fileHash, getPrettierUploadInfo, readDirSync } = require('../utils')
const { KEKE } = require('../consts')
const basename = path.basename
const authRequest = require('../authRequest')

// async function putSymlink (symKey, realKey) {
//   const now = new Date()
//   const params = {
//     key: `${symKey}`,
//     contentType: mimeType.lookup(realKey) || 'text/plain',
//     target: realKey,
//     subResource: '?symlink',
//     date: now.toGMTString()
//   }
//   console.log(params)
//   const { data: { authorizationHeader } } = await axios.get(`${HEIHEI}/authorization`, { params })
//   const res = await axios.put(`http://static-codefuture.oss-cn-hangzhou.aliyuncs.com/${symKey}?symlink`, '', {
//     headers: { 'Content-MD5': '', 'x-oss-symlink-target': realKey, 'Content-Type': params.contentType, 'Cache-Control': getCacheControl(params.contentType), Authorization: authorizationHeader, Date: params.date }
//   })
//   return res
// }

async function action (source, command) {
  var workingPath = ''
  const workingDirectory = process.cwd()
  const { codename, group, prefix, concurrent = 50, quiet } = command
  if (!codename) {
    console.error('无name配置，请检查配置是否正常。')
    return
  }
  if (!group) {
    console.error('无group配置，请检查配置是否正常。')
    return
  }

  if (source.startsWith('./')) {
    workingPath = workingDirectory + '/' + source.slice(2)
  } else if (source.startsWith('/')) {
    workingPath = source
  } else {
    workingPath = workingDirectory + '/' + source
  }

  var uploadList = readDirSync(workingPath, [], '')
    .filter((x) => !basename(x.localFile).startsWith('.'))
    .map(x => ({ ...x, fileData: fs.readFileSync(x.localFile) }))
    .map(x => ({ ...x, md5: fileHash(x.fileData) }))
  const snapshotMd5 = md5(Buffer.from(uploadList.map(x => x.md5).join('')))

  uploadList = uploadList.map(x => ({ ...x, key: `${prefix}/${snapshotMd5}${x.key}`, symKey: `${prefix}${x.key}` }))
  const files = uploadList.map(x => x.key)
  quiet || console.time('upload')
  const uploadedFilesInfo = await upload([...uploadList], { concurrent, quiet: command.quiet })
  quiet || console.timeEnd('upload')
  if (!quiet || command.verbose) {
    getPrettierUploadInfo(uploadedFilesInfo)
  }
  try {
    await authRequest.post(`${KEKE}/management/publish`, {
      hash: snapshotMd5,
      files: files,
      name: codename,
      group: group
    })
  } catch (err) {
    console.log(err)
  }
  if (!quiet) {
    console.log('✔上传成功')
  }
}

program
  .command('publish <source>')
  .option(
    '-p, --prefix <prefix>',
    '项目所在分组。'
  )
  .option(
    '-n, --codename <codename>',
    '项目所在分组。'
  )
  .option(
    '-g, --group <group>',
    '项目所在分组。'
  )
  .option(
    '-v, --verbose',
    '是否显示上传文件信息'
  )
  .option(
    '-q, --quit',
    '不显示任何信息'
  )
  .option('--allow-sourcemap [boolean]', '是否允许上传.map文件，默认禁止上传。')
  .description('将项目快照上传到服务器。使用source选项指定要上传的目录，name为项目名，如果不填写将使用当前工作目录下package.json里的name配置。')
  .action(action)

module.exports = action
