#!/usr/bin/env node
const axios = require('axios')
const mimeType = require('mime-types')
const _cliProgress = require('cli-progress')
const FormData = require('form-data')

const authRequest = require('../authRequest')
const { HEIHEI, STATIC_HOST } = require('../consts')
var progressBar
var processingCount = 0
var total
var uploadedFilesInfo = {}

async function compressImage (buffer, key) {
  const form = new FormData()
  form.append('file', buffer, key)
  return authRequest.post(`${HEIHEI}/compress`, form, { responseType: 'arraybuffer', headers: { ...form.getHeaders() } }).then(res => res.data)
}

function testWillBeCompressed (contentType) {
  return (
    contentType === 'image/png' ||
    contentType === 'image/jpeg' ||
    contentType === 'image/jpg'
  )
}

async function headFileInfo (key, hash, testRawFile = false) {
  try {
    const response = await axios.head(`${STATIC_HOST}/${key}`)
    if (testRawFile) {
      const rawFilerResponse = await axios.head(`${STATIC_HOST}/${key}.raw`)
      return { exitst: rawFilerResponse.headers['content-md5'] === hash, fileLength: response.headers['content-length'] }
    }
    return { exitst: response.headers['content-md5'] === hash }
  } catch (err) {
    // console.error(err)
    return { exitst: false }
  }
}

function getCacheControl (contentType) {
  var cacheControl
  if (contentType.indexOf('text/html') !== -1) {
    cacheControl = `max-age=${60}`
  } else if (contentType.indexOf('image/x-icon') !== -1) {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  } else if (contentType.indexOf('image') !== -1) {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  } else {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  }
  return cacheControl
}

async function uploadToOSS (key, fileData, meta) {
  const { data: signatureUrl } = await axios.get(`${HEIHEI}/signature`, { params: { name: key, ...meta } })
  return axios.put(signatureUrl, fileData, {
    headers: { 'Content-Type': meta.contentType, 'Cache-Control': getCacheControl(meta.contentType) }
  })
}

async function uploadFile (fileData, key, contentMd5) {
  const contentType = mimeType.lookup(key) || 'text/plain'
  const willBeCompressed = testWillBeCompressed(contentType)
  const rawLength = fileData.length
  const { exitst, fileLength } = await headFileInfo(key, contentMd5, willBeCompressed)
  if (exitst) {
    return {
      status: '304',
      compressInfo: {
        rawLength,
        compresedLength: fileLength || rawLength
      }
    }
  }

  // console.time('compress' + key)
  if (willBeCompressed) {
    await uploadToOSS(key + '.raw', fileData, {
      contentType,
      bucket: 'static-codefuture'
    })
    fileData = await compressImage(fileData, key)
  }
  // console.timeEnd('compress' + key)

  try {
    await uploadToOSS(key, fileData, {
      contentType,
      bucket: 'static-codefuture'
    })
    return {
      status: '200',
      compressInfo: {
        rawLength,
        compresedLength: fileData.length
      }
    }
  } catch (err) {
    // console.error(err)
    throw new Error('uploadFailed')
  }
}

function queueUpload (uploadList, i) {
  return new Promise((resolve, reject) => {
    while (i--) {
      _queueUpload(uploadList, resolve, reject)
    }
  })
}

function _queueUpload (uploadList, resolve, reject) {
  if (uploadList.length) {
    const { fileData, key, retry, md5 } = uploadList.pop()
    processingCount += 1
    uploadFile(fileData, key, md5)
      .then(({ status, compressInfo }) => {
        uploadedFilesInfo[key] = { status, compressInfo }
        processingCount -= 1
        progressBar && progressBar.update(total - processingCount)
        _queueUpload(uploadList, resolve, reject)
      })
      .catch((err) => {
        uploadedFilesInfo[key] = { err }
        processingCount -= 1
        if (retry) {
          uploadList.push({
            fileData,
            key,
            retry: retry - 1
          })
        }
        _queueUpload(uploadList, resolve, reject)
      })
  } else {
    if (!processingCount) {
      resolve()
    }
  }
}

async function upload (uploadList, options) {
  total = uploadList.length
  const quiet = options.quiet
  const i = options.concurrent
  quiet || (progressBar = new _cliProgress.SingleBar({}, _cliProgress.Presets.shades_classic))
  quiet || progressBar.start(total, 0)
  await queueUpload(uploadList, i)
  quiet || progressBar.stop()
  const info = { ...uploadedFilesInfo }
  uploadedFilesInfo = {}
  progressBar = null
  return info
}

module.exports = upload
