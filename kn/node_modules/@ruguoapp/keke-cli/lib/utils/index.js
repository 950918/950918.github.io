const fs = require('fs')
const mimeType = require('mime-types')
const os = require('os')
const path = require('path')
const md5 = require('md5')
const chalk = require('chalk')
const yaml = require('yaml')
const filesize = require('filesize')
const { MAX_RETRY, STATIC_HOST } = require('../consts')
const upload = require('./upload')
const home = os.homedir()

function fileHash (fileData) {
  // 阿里云OSS的md5算法不太一样
  // see also: https://help.aliyun.com/document_detail/31978.html?spm=a2c4g.11186623.6.794.731a147erlEp5A
  return Buffer.from(md5(fileData), 'hex').toString('base64')
}

function getPrettierUploadInfo (uploadedFilesInfo) {
  for (const key in uploadedFilesInfo) {
    const { err, status, compressInfo } = uploadedFilesInfo[key]
    if (err) {
      console.log(`[${err}]:${key}MAX_RETRY exceed`)
    } else {
      const reduceSize = compressInfo.rawLength - compressInfo.compresedLength
      const compressInfoString = reduceSize === 0 ? `${filesize(compressInfo.rawLength)}` : `${filesize(compressInfo.rawLength)} -> ${filesize(compressInfo.compresedLength)} ${(100 * reduceSize / compressInfo.rawLength).toFixed(0)}% saved`
      const link = `${STATIC_HOST}/${key}`
      console.log(`${chalk.green(`[${status}]:`)} ${chalk.cyan(link)} ${chalk.blue(compressInfoString)}`)
    }
  }
}

function readDirSyncFlat (currentFolder, dirs, prefix) {
  // const stat = fs.statSync(currentFolder)
  const uploadList = []
  fs.readdirSync(currentFolder).forEach(file => {
    const filePath = path.join(currentFolder, file)
    const stat = fs.statSync(filePath)
    if (stat.isFile()) {
      uploadList.push({
        localFile: filePath,
        key: file,
        retry: MAX_RETRY
      })
    }
  })
  return uploadList
}

function readDirSync (currentFolder, dirs, prefix) {
  const stat = fs.statSync(currentFolder)
  const uploadList = []
  if (stat.isDirectory()) {
    const pa = fs.readdirSync(currentFolder)
    pa.forEach((ele) => {
      const newDir = dirs.slice()
      newDir.push(ele)
      uploadList.push(...readDirSync(currentFolder + '/' + ele, newDir, prefix))
    })
  } else if (stat.isFile()) {
    uploadList.push({
      localFile: currentFolder,
      key: [prefix, ...dirs].join('/'),
      retry: MAX_RETRY
    })
  } else {
    console.error('不是有效的文件类型')
  }
  return uploadList
}

function getMetaData (key, md5) {
  const contentType = mimeType.lookup(key) || 'text/plain'
  var cacheControl
  if (contentType.indexOf('text/html') !== -1) {
    cacheControl = `max-age=${60}`
  } else if (contentType.indexOf('image/x-icon') !== -1) {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  } else if (contentType.indexOf('image') !== -1) {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  } else {
    cacheControl = `max-age=${60 * 60 * 24 * 30}`
  }
  return { contentType, cacheControl, key, md5 }
}

// function getCredentialsFilePath () {
//   const kekeDir = path.join(home, '.keke')
//   const credentialsFile = path.join(kekeDir, 'credentials')
//   return credentialsFile
// }

function writeCredentials (profile, token) {
  const kekeDir = path.join(home, '.keke')
  const credentialsFile = path.join(kekeDir, 'credentials')
  let credentials = {}
  try {
    credentials = readCredentials()
  } catch (err) {
    console.log(err)
  }
  credentials[profile] = token
  fs.writeFileSync(credentialsFile, yaml.stringify(credentials))
}

function readCredentials () {
  let credentials = {}
  const kekeDir = path.join(home, '.keke')
  const credentialsFile = path.join(kekeDir, 'credentials')
  try {
    fs.statSync(kekeDir)
  } catch (err) {
    fs.mkdirSync(kekeDir)
  }

  try {
    const file = fs.readFileSync(credentialsFile).toString()
    credentials = yaml.parse(file)
  } catch (err) {
  }
  return credentials
}

function readPackageJson () {
  const workingDirectory = process.cwd()
  const pkgFileText = fs.readFileSync(path.join(workingDirectory, 'package.json'))
  return JSON.parse(pkgFileText)
}

module.exports = {
  readDirSync,
  getMetaData,
  readCredentials,
  writeCredentials,
  getPrettierUploadInfo,
  readDirSyncFlat,
  upload,
  fileHash,
  readPackageJson
}
