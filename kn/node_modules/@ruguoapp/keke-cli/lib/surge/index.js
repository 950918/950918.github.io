const path = require('path')
const program = require('commander')
const prompts = require('prompts')
const ora = require('ora')
const fs = require('fs')
const publish = require('../publish')
const release = require('../release')
const { readPackageJson } = require('../utils')
async function promptConfig () {
  const onCancel = (prompt) => {
    console.log('bye')
    // throw Error('quit')
    process.exit()
    return true
  }
  const { dist } = await prompts({
    type: 'text',
    name: 'dist',
    initial: 'dist',
    message: '请填写要上传的文件夹相对路径'
  }, { onCancel })

  const { group } = await prompts({
    type: 'text',
    name: 'group',
    initial: 'h5-codefuture-top',
    message: '请填写group名，如果你不知道有什么，选择默认即可'
  }, { onCancel })

  const { codename } = await prompts({
    type: 'text',
    name: 'codename',
    initial: () => {
      try {
        const pkg = readPackageJson()
        return pkg.name
      } catch (err) {}
      return ''
    },
    message: '请填写项目名，项目地址将会是https://groupdomain/{codename}'
  }, { onCancel })

  const { prefix } = await prompts({
    type: 'text',
    name: 'prefix',
    initial: () => {
      const shortenGroupName = getShortenGroupName(group)
      return `${shortenGroupName ? shortenGroupName + '-' : ''}${codename}`
    },
    message: '请填写项目在OSS的存放目录，一般保持默认即可'
  }, { onCancel })

  console.log(`以下是你要发布的应用信息`)
  console.log(`你的应用将发布在 https://groupdomain/${codename}`)
  console.log(`你的应用publicPath将会是 https://static.codefuture.top/${prefix}`)

  const { confirm } = await prompts({
    type: 'confirm',
    name: 'confirm',
    message: '确认发布吗？',
    initial: true
  }, { onCancel })

  if (!confirm) {
    onCancel()
  }

  return { codename, group, source: dist, prefix }
}

function getShortenGroupName (group) {
  let shortenGroupName = group
  if (group === 'h5-codefuture-top') {
    shortenGroupName = undefined
  }
  return shortenGroupName
}

function readConfig () {
  let config = {}
  const pkg = readPackageJson()
  config = pkg.keke
  if (!pkg.keke) {
    console.error('❌ 没有在package.json中找到keke配置项')
    return undefined
  }
  // const kekeConfigFile = path.join(workingDirectory, '.kekerc')
  // try {
  //   const file = fs.readFileSync(kekeConfigFile).toString()
  //   config = yaml.parse(file)
  // } catch (err) {
  //   console.log('❌ 没有找到.kekerc')
  //   return undefined
  // }
  return config
}

function writeConfig (newConfig) {
  const workingDirectory = process.cwd()
  const kekeConfigFile = path.join(workingDirectory, 'package.json')
  const pkg = readPackageJson()
  let kekeConfig = {}
  try {
    kekeConfig = readConfig()
  } catch (err) {
    console.log(err)
  }
  kekeConfig = { ...kekeConfig, ...newConfig }
  const configKeys = Object.keys(pkg).filter(x => x !== 'keke')
  const insertIndex = configKeys.indexOf('scripts') + 1
  configKeys.splice(insertIndex, 0, 'keke')
  pkg.keke = kekeConfig
  fs.writeFileSync(kekeConfigFile, JSON.stringify(configKeys.reduce((o, key) => ({ ...o, [key]: pkg[key] }), {}), null, 2))
}

async function action (source = 'dist', command) {
  // const workingDirectory = process.cwd()
  // const pkg = require(path.join(workingDirectory, 'package.json'))
  // const name = command.name || pkg.name
  // const group = command.group || pkg.group || 'h5-codefuture-top'
  // const concurrent = command.concurrent || 50
  let kekeConfig = {}
  const { verbose } = command
  if (!command.group && !command.codename) {
    kekeConfig = readConfig()
    if (!kekeConfig) {
      kekeConfig = await promptConfig()
      writeConfig(kekeConfig)
    }
  } else {
    if (!command.codename || !command.group) {
      console.error('请填写name和group')
      return
    }
    const shortenGroupName = getShortenGroupName(command.group)
    const codename = command.codename
    kekeConfig = {
      ...kekeConfig,
      source,
      group: command.group,
      codename,
      prefix: command.prefix || `${shortenGroupName ? shortenGroupName + '-' : ''}${codename}`
    }
  }
  kekeConfig = { ...kekeConfig, quiet: !verbose, prod: command.prod, allowSourcemap: command.allowSourcemap, concurrent: command.concurrent }
  const publishingSpinner = verbose || ora('publishing').start()
  await publish(kekeConfig.source, kekeConfig)
  verbose || publishingSpinner.succeed()
  const releaseSpinner = verbose || ora('releaseing').start()
  await release(kekeConfig)
  verbose || releaseSpinner.succeed()
  console.log(`publicPath: https://static.codefuture.top/${kekeConfig.prefix}`)
}

program.command('surge [source]')
  .description('使用surge命令来进行一键上传发版，surge命令会依次执行upload，publish，release三个步骤。第一次运行surge命令将会有一个交互式命令行来帮助你生成一些配置')
  .option(
    '-n, --codename <codename>',
    '项目名。'
  )
  .option(
    '-g, --group <group>',
    '项目组名。'
  )
  .option(
    '--prod',
    '发布到prod环境，如果不开启此项配置将默认发布到beta环境'
  )
  .option(
    '-p, --prefix <prefix>',
    '上传到OSS的前缀，会自动生成。如果你不了解怎么写可以留空。'
  )
  .option(
    '-v, --verbose',
    '显示辅助信息。'
  )
  .option('-c, --concurrent <concurrent>', 'the number of concurrent upload.')
  .option('--allow-sourcemap', 'allow sourcemap uploading.')
  .action(action)
